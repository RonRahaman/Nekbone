      subroutine ax_cuda(w,u,ur,us,ut,gxyz,dxm1,dxtm1)

        use cudafor

        real, intent(out) :: w(nx1,ny1,nz1,nelt)
        real, intent(in)  :: u(nx1,ny1,nz1,nelt)
        real ur  (nx1,ny1,nz1,lelt)
        real us  (nx1,ny1,nz1,lelt)
        real ut  (nx1,ny1,nz1,lelt)

        real gxyz(nx1,ny1,nz1,2*ldim,lelt)

        real, intent(in) :: dxm1(nx1,nx1)
        real, intent(in) :: dxtm1(nx1,nx1)

c       w = 0.0
c       u = 1.0
c       ur = -1.0
c       us = -1.0
c       ut = -1.0
c       gxyz = 1.0
c       dxm1 = 1.0
c       dxtm1 = 1.0

!$ACC HOST_DATA USE_DEVICE(w,u(:,:,:,:),ur,us,ut,gxyz,dxm1,dxtm1)

        if (nx.eq.2 .or. nx.eq.16) then
          call ax_cuda_16<<<nelt,dim3(nx1,ny1,nz1/4)>>>(w,u,ur,us,ut,
     $      gxyz,dxm1,dxtm1) 
        else if (nx1.eq.8) then
          call ax_cuda_8<<<nelt,dim3(nx1,ny1,nz1)>>>(w,u,ur,us,ut,
     $        gxyz,dxm1,dxtm1)
        else if (nx1.eq.10) then
          call ax_cuda_10<<<nelt,dim3(nx1,ny1,nz1)>>>(w,u,ur,us,ut,
     $        gxyz,dxm1,dxtm1)
        else if (nx1.eq.12) then
          call ax_cuda_12<<<nelt,dim3(nx1,ny1,nz1/2)>>>(w,u,ur,us,ut,
     $        gxyz,dxm1,dxtm1)
        else 
          call err_chk(1,
     $ "CUDA kernel supports only nx1 = 2, 8, 10, 12, or 16")
        endif
        istat = cudaDeviceSynchronize()

!$ACC END HOST_DATA
      return
      end

c-------------------------------------------------------------------------
      attributes(global) subroutine ax_cuda_01( 
     $    w,u,ur,us,ut,gxyz,dxm1,dxtm1)

      include 'SIZE'

      real, intent(out) :: w(lx1,ly1,lz1,lelt)
      real, intent(in)  :: u(lx1,ly1,lz1,lelt)
      real ur  (lx1,ly1,lz1,lelt)
      real us  (lx1,ly1,lz1,lelt)
      real ut  (lx1,ly1,lz1,lelt)

      real gxyz(6,lx1,ly1,lz1,lelt)

      real, intent(in) :: dxm1(lx1,lx1)
      real, intent(in) :: dxtm1(lx1,lx1)

      real rtmp,stmp,ttmp,wijke
      real, shared :: shdxm1(lx1,lx1)
      real, shared :: shdxtm1(lx1,lx1)
      real, shared :: shur(lx1,ly1,lz1)
      real, shared :: shus(lx1,ly1,lz1)
      real, shared :: shut(lx1,ly1,lz1)
      integer e,i,j,k,l

      e = blockIdx%x
      k = threadIdx%z
      j = threadIdx%y
      i = threadIdx%x

      if (k.eq.1) then
         shdxm1(i,j) = dxm1(i,j)
         shdxtm1(i,j) = dxtm1(i,j)
      end if
      call syncthreads()

      rtmp = 0.0
      stmp = 0.0
      ttmp = 0.0
      do l=1,lx1
        rtmp = rtmp+shdxm1(i,l)*u(l,j,k,e)
        stmp = stmp+shdxm1(j,l)*u(i,l,k,e)
        ttmp = ttmp+shdxm1(k,l)*u(i,j,l,e)
      enddo
          shur(i,j,k) = gxyz(1,i,j,k,e)*rtmp
     $                + gxyz(2,i,j,k,e)*stmp
     $                + gxyz(3,i,j,k,e)*ttmp

          shus(i,j,k) = gxyz(2,i,j,k,e)*rtmp
     $                + gxyz(4,i,j,k,e)*stmp
     $                + gxyz(5,i,j,k,e)*ttmp

          shut(i,j,k) = gxyz(3,i,j,k,e)*rtmp
     $                + gxyz(5,i,j,k,e)*stmp
     $                + gxyz(6,i,j,k,e)*ttmp

      call syncthreads()

      wijke = 0.0
      do l=1,lx1
               wijke = wijke + shdxtm1(i,l)*shur(l,j,k) 
     $                       + shdxtm1(j,l)*shus(i,l,k)
     $                       + shdxtm1(k,l)*shut(i,j,l)
      enddo
      w(i,j,k,e) = wikje
      ur(i,j,k,e) = shur(i,j,k)
      us(i,j,k,e) = shus(i,j,k)
      ut(i,j,k,e) = shut(i,j,k)
      return
      end
c-------------------------------------------------------------------------
      attributes(global) subroutine ax_cuda_02(
     $    w,u,ur,us,ut, gxyz,dxm1,dxtm1)

      include 'SIZE'

      real, intent(out) :: w(lx1,ly1,lz1,lelt)
      real, intent(in)  :: u(lx1,ly1,lz1,lelt)
      real ur  (lx1,ly1,lz1,lelt)
      real us  (lx1,ly1,lz1,lelt)
      real ut  (lx1,ly1,lz1,lelt)

      real gxyz(lx1,ly1,lz1,2*ldim,lelt)

      real, intent(in) :: dxm1(lx1,lx1)
      real, intent(in) :: dxtm1(lx1,lx1)

      real rtmp,stmp,ttmp,wijke
      real, shared :: shdxm1(lx1,lx1)
      real, shared :: shdxtm1(lx1,lx1)
      real, shared :: shur(lx1,ly1,lz1)
      real, shared :: shus(lx1,ly1,lz1)
      real, shared :: shut(lx1,ly1,lz1)
      integer e,i,j,k,l

      e = blockIdx%x
      k = threadIdx%z
      j = threadIdx%y
      i = threadIdx%x

      if (k.eq.1) then
         shdxm1(i,j) = dxm1(i,j)
         shdxtm1(i,j) = dxtm1(i,j)
      end if
      call syncthreads()

      rtmp = 0.0
      stmp = 0.0
      ttmp = 0.0
      do l=1,lx1
        rtmp = rtmp+shdxm1(i,l)*u(l,j,k,e)
        stmp = stmp+shdxm1(j,l)*u(i,l,k,e)
        ttmp = ttmp+shdxm1(k,l)*u(i,j,l,e)
      enddo
          shur(i,j,k) = gxyz(i,j,k,1,e)*rtmp
     $                + gxyz(i,j,k,2,e)*stmp
     $                + gxyz(i,j,k,3,e)*ttmp

          shus(i,j,k) = gxyz(i,j,k,2,e)*rtmp
     $                + gxyz(i,j,k,4,e)*stmp
     $                + gxyz(i,j,k,5,e)*ttmp

          shut(i,j,k) = gxyz(i,j,k,3,e)*rtmp
     $                + gxyz(i,j,k,5,e)*stmp
     $                + gxyz(i,j,k,6,e)*ttmp

      call syncthreads()

      wijke = 0.0
      do l=1,lx1
               wijke = wijke + shdxtm1(i,l)*shur(l,j,k) 
     $                       + shdxtm1(j,l)*shus(i,l,k)
     $                       + shdxtm1(k,l)*shut(i,j,l)
      enddo
      w(i,j,k,e) = wijke
      ur(i,j,k,e) = shur(i,j,k)
      us(i,j,k,e) = shus(i,j,k)
      ut(i,j,k,e) = shut(i,j,k)
      return
      end
c-------------------------------------------------------------------------
      attributes(global) subroutine ax_cuda_08(
     $    w,u,ur,us,ut,gxyz,dxm1,dxtm1)

      include 'SIZE'

      real, intent(out) :: w(lx1,ly1,lz1,lelt)
      real, intent(in)  :: u(lx1,ly1,lz1,lelt)
      real ur  (lx1,ly1,lz1,lelt)
      real us  (lx1,ly1,lz1,lelt)
      real ut  (lx1,ly1,lz1,lelt)

      real gxyz(lx1,ly1,lz1,2*ldim,lelt)

      real, intent(in) :: dxm1(lx1,lx1)
      real, intent(in) :: dxtm1(lx1,lx1)

      real rtmp,stmp,ttmp,wijke
      real, shared :: shdxm1(lx1,lx1)
      real, shared :: shdxtm1(lx1,lx1)
      real, shared :: shur(lx1,ly1,lz1)
      real, shared :: shus(lx1,ly1,lz1)
      real, shared :: shut(lx1,ly1,lz1)
      integer e,i,j,k,l

      e = blockIdx%x
      k = threadIdx%z
      j = threadIdx%y
      i = threadIdx%x

      if (k.eq.1) then
         shdxm1(i,j) = dxm1(i,j)
         shdxtm1(i,j) = dxtm1(i,j)
      end if
      call syncthreads()

      rtmp = 0.0
      stmp = 0.0
      ttmp = 0.0
      do l=1,lx1
        rtmp = rtmp+shdxm1(i,l)*u(l,j,k,e)
        stmp = stmp+shdxm1(j,l)*u(i,l,k,e)
        ttmp = ttmp+shdxm1(k,l)*u(i,j,l,e)
      enddo
          shur(i,j,k) = gxyz(i,j,k,1,e)*rtmp
     $                + gxyz(i,j,k,2,e)*stmp
     $                + gxyz(i,j,k,3,e)*ttmp

          shus(i,j,k) = gxyz(i,j,k,2,e)*rtmp
     $                + gxyz(i,j,k,4,e)*stmp
     $                + gxyz(i,j,k,5,e)*ttmp

          shut(i,j,k) = gxyz(i,j,k,3,e)*rtmp
     $                + gxyz(i,j,k,5,e)*stmp
     $                + gxyz(i,j,k,6,e)*ttmp

      call syncthreads()

      wijke = 0.0
      do l=1,lx1
               wijke = wijke + shdxtm1(i,l)*shur(l,j,k) 
     $                       + shdxtm1(j,l)*shus(i,l,k)
     $                       + shdxtm1(k,l)*shut(i,j,l)
      enddo
      w(i,j,k,e) = wijke
c      ur(i,j,k,e) = shur(i,j,k)
c      us(i,j,k,e) = shus(i,j,k)
c      ut(i,j,k,e) = shut(i,j,k)
      return
      end
c-------------------------------------------------------------------------
      attributes(global) subroutine ax_cuda_10(
     $    w,u,ur,us,ut,gxyz,dxm1,dxtm1)

      include 'SIZE'

      real, intent(out) :: w(lx1,ly1,lz1,lelt)
      real, intent(in)  :: u(lx1,ly1,lz1,lelt)
      real ur  (lx1,ly1,lz1,lelt)
      real us  (lx1,ly1,lz1,lelt)
      real ut  (lx1,ly1,lz1,lelt)

      real gxyz(lx1,ly1,lz1,2*ldim,lelt)

      real, intent(in) :: dxm1(lx1,lx1)
      real, intent(in) :: dxtm1(lx1,lx1)

      real rtmp,stmp,ttmp,wijk1e,wijk2e
      real, shared :: shdxm1(lx1,lx1)
      real, shared :: shdxtm1(lx1,lx1)
      real, shared :: shur(lx1,ly1,lz1)
      real, shared :: shus(lx1,ly1,lz1)
      real, shared :: shut(lx1,ly1,lz1)
      integer e,i,j,k,l

      e = blockIdx%x
      k = threadIdx%z
      j = threadIdx%y
      i = threadIdx%x

      if (k.eq.1) then
         shdxm1(i,j) = dxm1(i,j)
         shdxtm1(i,j) = dxtm1(i,j)
      end if
      call syncthreads()

      rtmp = 0.0
      stmp = 0.0
      ttmp = 0.0
      do l=1,lx1
        rtmp = rtmp+shdxm1(i,l)*u(l,j,k,e)
        stmp = stmp+shdxm1(j,l)*u(i,l,k,e)
        ttmp = ttmp+shdxm1(k,l)*u(i,j,l,e)
      enddo
          shur(i,j,k) = gxyz(i,j,k,1,e)*rtmp
     $                + gxyz(i,j,k,2,e)*stmp
     $                + gxyz(i,j,k,3,e)*ttmp

          shus(i,j,k) = gxyz(i,j,k,2,e)*rtmp
     $                + gxyz(i,j,k,4,e)*stmp
     $                + gxyz(i,j,k,5,e)*ttmp

          shut(i,j,k) = gxyz(i,j,k,3,e)*rtmp
     $                + gxyz(i,j,k,5,e)*stmp
     $                + gxyz(i,j,k,6,e)*ttmp

      rtmp = 0.0
      stmp = 0.0
      ttmp = 0.0
      do l=1,lx1
        rtmp = rtmp+shdxm1(i,l)*u(l,j,k+5,e)
        stmp = stmp+shdxm1(j,l)*u(i,l,k+5,e)
        ttmp = ttmp+shdxm1(k+5,l)*u(i,j,l,e)
      enddo
          shur(i,j,k+5) = gxyz(i,j,k+5,1,e)*rtmp
     $                  + gxyz(i,j,k+5,2,e)*stmp
     $                  + gxyz(i,j,k+5,3,e)*ttmp

          shus(i,j,k+5) = gxyz(i,j,k+5,2,e)*rtmp
     $                  + gxyz(i,j,k+5,4,e)*stmp
     $                  + gxyz(i,j,k+5,5,e)*ttmp

          shut(i,j,k+5) = gxyz(i,j,k+5,3,e)*rtmp
     $                  + gxyz(i,j,k+5,5,e)*stmp
     $                  + gxyz(i,j,k+5,6,e)*ttmp


      call syncthreads()

      wijk1e = 0.0
      wijk2e = 0.0
      do l=1,lx1
               wijk1e = wijk1e + shdxtm1(i,l)*shur(l,j,k) 
     $                         + shdxtm1(j,l)*shus(i,l,k)
     $                         + shdxtm1(k,l)*shut(i,j,l)
               wijk2e = wijk2e + shdxtm1(i,l)*shur(l,j,k+5) 
     $                         + shdxtm1(j,l)*shus(i,l,k+5)
     $                         + shdxtm1(k+5,l)*shut(i,j,l)
      enddo
      w(i,j,k,e) = wijk1e
      w(i,j,k+5,e) = wijk2e
c      ur(i,j,k,e) = shur(i,j,k)
c      us(i,j,k,e) = shus(i,j,k)
c      ut(i,j,k,e) = shut(i,j,k)
c      ur(i,j,k+5,e) = shur(i,j,k+5)
c      us(i,j,k+5,e) = shus(i,j,k+5)
c      ut(i,j,k+5,e) = shut(i,j,k+5)
      return
      end
c-------------------------------------------------------------------------
      attributes(global) subroutine ax_cuda_12(
     $    w,u,ur,us,ut, gxyz,dxm1,dxtm1)

      include 'SIZE'

      real, intent(out) :: w(lx1,ly1,lz1,lelt)
      real, intent(in)  :: u(lx1,ly1,lz1,lelt)
      real ur  (lx1,ly1,lz1,lelt)
      real us  (lx1,ly1,lz1,lelt)
      real ut  (lx1,ly1,lz1,lelt)

      real gxyz(lx1,ly1,lz1,2*ldim,lelt)

      real, intent(in) :: dxm1(lx1,lx1)
      real, intent(in) :: dxtm1(lx1,lx1)

      real rtmp,stmp,ttmp,wijk1e,wijk2e
      real, shared :: shdxm1(lx1,lx1)
      real, shared :: shdxtm1(lx1,lx1)
      real, shared :: shur(lx1,ly1,lz1)
      real, shared :: shus(lx1,ly1,lz1)
      real, shared :: shut(lx1,ly1,lz1)
      integer e,i,j,k,l

      e = blockIdx%x
      k = threadIdx%z
      j = threadIdx%y
      i = threadIdx%x

      if (k.eq.1) then
         shdxm1(i,j) = dxm1(i,j)
         shdxtm1(i,j) = dxtm1(i,j)
      end if
      call syncthreads()

      rtmp = 0.0
      stmp = 0.0
      ttmp = 0.0
      do l=1,lx1
        rtmp = rtmp+shdxm1(i,l)*u(l,j,k,e)
        stmp = stmp+shdxm1(j,l)*u(i,l,k,e)
        ttmp = ttmp+shdxm1(k,l)*u(i,j,l,e)
      enddo
          shur(i,j,k) = gxyz(i,j,k,1,e)*rtmp
     $                + gxyz(i,j,k,2,e)*stmp
     $                + gxyz(i,j,k,3,e)*ttmp

          shus(i,j,k) = gxyz(i,j,k,2,e)*rtmp
     $                + gxyz(i,j,k,4,e)*stmp
     $                + gxyz(i,j,k,5,e)*ttmp

          shut(i,j,k) = gxyz(i,j,k,3,e)*rtmp
     $                + gxyz(i,j,k,5,e)*stmp
     $                + gxyz(i,j,k,6,e)*ttmp

      rtmp = 0.0
      stmp = 0.0
      ttmp = 0.0
      do l=1,lx1
        rtmp = rtmp+shdxm1(i,l)*u(l,j,k+6,e)
        stmp = stmp+shdxm1(j,l)*u(i,l,k+6,e)
        ttmp = ttmp+shdxm1(k+6,l)*u(i,j,l,e)
      enddo
          shur(i,j,k+6) = gxyz(i,j,k+6,1,e)*rtmp
     $                  + gxyz(i,j,k+6,2,e)*stmp
     $                  + gxyz(i,j,k+6,3,e)*ttmp

          shus(i,j,k+6) = gxyz(i,j,k+6,2,e)*rtmp
     $                  + gxyz(i,j,k+6,4,e)*stmp
     $                  + gxyz(i,j,k+6,5,e)*ttmp

          shut(i,j,k+6) = gxyz(i,j,k+6,3,e)*rtmp
     $                  + gxyz(i,j,k+6,5,e)*stmp
     $                  + gxyz(i,j,k+6,6,e)*ttmp


      call syncthreads()

      wijk1e = 0.0
      wijk2e = 0.0
      do l=1,lx1
               wijk1e = wijk1e + shdxtm1(i,l)*shur(l,j,k) 
     $                         + shdxtm1(j,l)*shus(i,l,k)
     $                         + shdxtm1(k,l)*shut(i,j,l)
               wijk2e = wijk2e + shdxtm1(i,l)*shur(l,j,k+6) 
     $                         + shdxtm1(j,l)*shus(i,l,k+6)
     $                         + shdxtm1(k+6,l)*shut(i,j,l)
      enddo
      w(i,j,k,e) = wijk1e
      w(i,j,k+6,e) = wijk2e
c      ur(i,j,k,e) = shur(i,j,k)
c      us(i,j,k,e) = shus(i,j,k)
c      ut(i,j,k,e) = shut(i,j,k)
c      ur(i,j,k+6,e) = shur(i,j,k+6)
c      us(i,j,k+6,e) = shus(i,j,k+6)
c      ut(i,j,k+6,e) = shut(i,j,k+6)

      return
      end
c-------------------------------------------------------------------------
      attributes(global) subroutine ax_cuda_14(
     $    w,u,ur,us,ut, gxyz,dxm1,dxtm1)

      include 'SIZE'

      real, intent(out) :: w(lx1,ly1,lz1,lelt)
      real, intent(in)  :: u(lx1,ly1,lz1,lelt)
      real ur  (lx1,ly1,lz1,lelt)
      real us  (lx1,ly1,lz1,lelt)
      real ut  (lx1,ly1,lz1,lelt)

      real gxyz(lx1,ly1,lz1,2*ldim,lelt)

      real, intent(in) :: dxm1(lx1,lx1)
      real, intent(in) :: dxtm1(lx1,lx1)

      real rtmp,stmp,ttmp,wijk1e,wijk2e
      real, shared :: shdxm1(lx1,lx1)
      real, shared :: shdxtm1(lx1,lx1)

      real, shared :: shur(lx1,ly1,lz1)
      real, shared :: shus(lx1,ly1,lz1)
c      real, shared :: shut(lx1,ly1,lz1)
      integer e,i,j,k,l

      e = blockIdx%x
      k = threadIdx%z
      j = threadIdx%y
      i = threadIdx%x

      if (k.eq.1) then
         shdxm1(i,j) = dxm1(i,j)
         shdxtm1(i,j) = dxtm1(i,j)
      end if
      call syncthreads()

      rtmp = 0.0
      stmp = 0.0
      ttmp = 0.0
      do l=1,lx1
        rtmp = rtmp+shdxm1(i,l)*u(l,j,k,e)
        stmp = stmp+shdxm1(j,l)*u(i,l,k,e)
        ttmp = ttmp+shdxm1(k,l)*u(i,j,l,e)
      enddo
          shur(i,j,k) = gxyz(i,j,k,1,e)*rtmp
     $                + gxyz(i,j,k,2,e)*stmp
     $                + gxyz(i,j,k,3,e)*ttmp

          shus(i,j,k) = gxyz(i,j,k,2,e)*rtmp
     $                + gxyz(i,j,k,4,e)*stmp
     $                + gxyz(i,j,k,5,e)*ttmp

          ut(i,j,k,e) = gxyz(i,j,k,3,e)*rtmp
     $                + gxyz(i,j,k,5,e)*stmp
     $                + gxyz(i,j,k,6,e)*ttmp

      rtmp = 0.0
      stmp = 0.0
      ttmp = 0.0
      do l=1,lx1
        rtmp = rtmp+shdxm1(i,l)*u(l,j,k+7,e)
        stmp = stmp+shdxm1(j,l)*u(i,l,k+7,e)
        ttmp = ttmp+shdxm1(k+7,l)*u(i,j,l,e)
      enddo
          shur(i,j,k+7) = gxyz(i,j,k+7,1,e)*rtmp
     $                  + gxyz(i,j,k+7,2,e)*stmp
     $                  + gxyz(i,j,k+7,3,e)*ttmp

          shus(i,j,k+7) = gxyz(i,j,k+7,2,e)*rtmp
     $                  + gxyz(i,j,k+7,4,e)*stmp
     $                  + gxyz(i,j,k+7,5,e)*ttmp

          ut(i,j,k+7,e) = gxyz(i,j,k+7,3,e)*rtmp
     $                  + gxyz(i,j,k+7,5,e)*stmp
     $                  + gxyz(i,j,k+7,6,e)*ttmp


      call syncthreads()

      wijk1e = 0.0
      wijk2e = 0.0
      do l=1,lx1
               wijk1e = wijk1e + shdxtm1(i,l)*shur(l,j,k) 
     $                         + shdxtm1(j,l)*shus(i,l,k)
     $                         + shdxtm1(k,l)*ut(i,j,l,e)
               wijk2e = wijk2e + shdxtm1(i,l)*shur(l,j,k+7) 
     $                         + shdxtm1(j,l)*shus(i,l,k+7)
     $                         + shdxtm1(k+7,l)*ut(i,j,l,e)
      enddo
      w(i,j,k,e) = wijk1e
      w(i,j,k+7,e) = wijk2e

      return
      end
c-------------------------------------------------------------------------
      attributes(global) subroutine ax_cuda_16(
     $    w,u,ur,us,ut,gxyz,dxm1,dxtm1)

      include 'SIZE'

      real, intent(out) :: w(lx1,ly1,lz1,lelt)
c      real, intent(in)  :: u(lx1,ly1,lz1,lelt)
      real u(lx1,ly1,lz1,lelt)
      real ur  (lx1,ly1,lz1,lelt)
      real us  (lx1,ly1,lz1,lelt)
      real ut  (lx1,ly1,lz1,lelt)

      real gxyz(lx1,ly1,lz1,2*ldim,lelt)

      real, intent(in) :: dxm1(lx1,lx1)
      real, intent(in) :: dxtm1(lx1,lx1)

      real rtmp,stmp,ttmp,wijke
      real, shared :: shdxm1(lx1,ly1)
      real, shared :: shdxtm1(lx1,ly1)
      real, shared :: shus(lx1,ly1,lz1/4)
      real, shared :: shut(lx1,ly1,lz1)
      integer l,e,i,j,k

      e = blockIdx%x
      k = threadIdx%z
      j = threadIdx%y
      i = threadIdx%x

      if (k.eq.1) then
         shdxm1(i,j) = dxm1(i,j)
         shdxtm1(i,j) = dxtm1(i,j)
      end if
      call syncthreads()

      rtmp = 0.0
      stmp = 0.0
      ttmp = 0.0
      do l=1,lx1
        rtmp = rtmp + shdxm1(i,l)    * u(l,j,k+12,e)
        stmp = stmp + shdxm1(j,l)    * u(i,l,k+12,e)
        ttmp = ttmp + shdxm1(k+12,l) * u(i,j,l,e)
      enddo
      ur(i,j,k+12,e) = gxyz(i,j,k+12,1,e)*rtmp
     $               + gxyz(i,j,k+12,2,e)*stmp
     $               + gxyz(i,j,k+12,3,e)*ttmp
      us(i,j,k+12,e) = gxyz(i,j,k+12,2,e)*rtmp
     $               + gxyz(i,j,k+12,4,e)*stmp
     $               + gxyz(i,j,k+12,5,e)*ttmp
      shut(i,j,k+12) = gxyz(i,j,k+12,3,e)*rtmp
     $               + gxyz(i,j,k+12,5,e)*stmp
     $               + gxyz(i,j,k+12,6,e)*ttmp

      call syncthreads()

      rtmp = 0.0
      stmp = 0.0
      ttmp = 0.0
      do l=1,lx1
        rtmp = rtmp + shdxm1(i,l)   * u(l,j,k+8,e)
        stmp = stmp + shdxm1(j,l)   * u(i,l,k+8,e)
        ttmp = ttmp + shdxm1(k+8,l) * u(i,j,l,e)
      enddo
      ur(i,j,k+8,e) = gxyz(i,j,k+8,1,e)*rtmp
     $              + gxyz(i,j,k+8,2,e)*stmp
     $              + gxyz(i,j,k+8,3,e)*ttmp
      us(i,j,k+8,e) = gxyz(i,j,k+8,2,e)*rtmp
     $              + gxyz(i,j,k+8,4,e)*stmp
     $              + gxyz(i,j,k+8,5,e)*ttmp
      shut(i,j,k+8) = gxyz(i,j,k+8,3,e)*rtmp
     $              + gxyz(i,j,k+8,5,e)*stmp
     $              + gxyz(i,j,k+8,6,e)*ttmp

      call syncthreads()

      rtmp = 0.0
      stmp = 0.0
      ttmp = 0.0
      do l=1,lx1
        rtmp = rtmp + shdxm1(i,l)   * u(l,j,k+4,e)
        stmp = stmp + shdxm1(j,l)   * u(i,l,k+4,e)
        ttmp = ttmp + shdxm1(k+4,l) * u(i,j,l,e)
      enddo
      ur(i,j,k+4,e) = gxyz(i,j,k+4,1,e)*rtmp
     $              + gxyz(i,j,k+4,2,e)*stmp
     $              + gxyz(i,j,k+4,3,e)*ttmp
      us(i,j,k+4,e) = gxyz(i,j,k+4,2,e)*rtmp
     $              + gxyz(i,j,k+4,4,e)*stmp
     $              + gxyz(i,j,k+4,5,e)*ttmp
      shut(i,j,k+4) = gxyz(i,j,k+4,3,e)*rtmp
     $              + gxyz(i,j,k+4,5,e)*stmp
     $              + gxyz(i,j,k+4,6,e)*ttmp
      call syncthreads()

      rtmp = 0.0
      stmp = 0.0
      ttmp = 0.0
      do l=1,lx1
        rtmp = rtmp + shdxm1(i,l)   * u(l,j,k,e)
        stmp = stmp + shdxm1(j,l)   * u(i,l,k,e)
        ttmp = ttmp + shdxm1(k,l) * u(i,j,l,e)
      enddo

      ur(i,j,k,e) = gxyz(i,j,k,1,e)*rtmp
     $            + gxyz(i,j,k,2,e)*stmp
     $            + gxyz(i,j,k,3,e)*ttmp
      shus(i,j,k) = gxyz(i,j,k,2,e)*rtmp
     $            + gxyz(i,j,k,4,e)*stmp
     $            + gxyz(i,j,k,5,e)*ttmp
      shut(i,j,k) = gxyz(i,j,k,3,e)*rtmp
     $            + gxyz(i,j,k,5,e)*stmp
     $            + gxyz(i,j,k,6,e)*ttmp

      call syncthreads()
      wijke = 0.0
      do l=1,lx1
        wijke = wijke + shdxtm1(i,l)*ur(l,j,k,e) 
     $                + shdxtm1(j,l)*shus(i,l,k)
     $                + shdxtm1(k,l)*shut(i,j,l)
      enddo
      w(i,j,k,e) = wijke

      call syncthreads()
      shus(i,j,k) = us(i,j,k+4,e)
      call syncthreads()
      wijke = 0.0
      do l=1,lx1
        wijke = wijke + shdxtm1(i,l)*ur(l,j,k+4,e) 
     $                + shdxtm1(j,l)*shus(i,l,k)
     $                + shdxtm1(k+4,l)*shut(i,j,l)
      enddo
      w(i,j,k+4,e) = wijke

      call syncthreads()
      shus(i,j,k) = us(i,j,k+8,e)
      call syncthreads()
      wijke = 0.0
      do l=1,lx1
        wijke = wijke + shdxtm1(i,l)*ur(l,j,k+8,e) 
     $                + shdxtm1(j,l)*shus(i,l,k)
     $                + shdxtm1(k+8,l)*shut(i,j,l)
      enddo
      w(i,j,k+8,e) = wijke

      call syncthreads()
      shus(i,j,k) = us(i,j,k+12,e)
      call syncthreads()
      wijke = 0.0
      do l=1,lx1
        wijke = wijke + shdxtm1(i,l)*ur(l,j,k+12,e) 
     $                + shdxtm1(j,l)*shus(i,l,k)
     $                + shdxtm1(k+12,l)*shut(i,j,l)
      enddo
      w(i,j,k+12,e) = wijke

      return
      end
c-------------------------------------------------------------------------
